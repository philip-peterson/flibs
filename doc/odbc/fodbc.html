
<html><head>
<title>flibs/odbc - flibs</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.toc,UL.toc UL, UL.toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.section, LI.subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.requirements LI, UL.syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'odbc/fodbc.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2012 Arjen Markus &lt;arjenmarkus@sourceforge.net&gt;
   -->
<! -- CVS: $Id: fodbc.html,v 1.3 2013/05/13 08:03:15 knystrom Exp $ flibs/odbc.n
   -->
<body><div class="doctools">
<h1 class="title">flibs/odbc(n) 1.1  &quot;flibs&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>flibs/odbc - Interface to ODBC</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">DATA TYPES</a></li>
<li class="section"><a href="#section3">ROUTINES</a></li>
<li class="section"><a href="#section4">ODBC-SPECIFIC ROUTINES</a></li>
<li class="section"><a href="#section5">EXAMPLE</a></li>
<li class="section"><a href="#section6">LIMITATIONS</a></li>
<li class="section"><a href="#section7">IMPLEMENTATION NOTES</a></li>
<li class="section"><a href="#section8">PLATFORM ISSUES</a></li>
<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="syntax">
<li><a href="#1"><b class="cmd">type(ODBC_DATABASE)</b></a></li>
<li><a href="#2"><b class="cmd">type(ODBC_STATEMENT)</b></a></li>
<li><a href="#3"><b class="cmd">type(ODBC_COLUMN)</b></a></li>
<li><a href="#4"><b class="cmd">call odbc_column_props( column, name, type, length )</b></a></li>
<li><a href="#5"><b class="cmd">call odbc_column_query( column, name, type, length, function )</b></a></li>
<li><a href="#6"><b class="cmd">call odbc_set_column( column, value )</b></a></li>
<li><a href="#7"><b class="cmd">call odbc_get_column( column, value )</b></a></li>
<li><a href="#8"><b class="cmd">call odbc_open( filename_or_data_set_name, driver, db )</b></a></li>
<li><a href="#9"><b class="cmd">call odbc_connect( connection_string, db )</b></a></li>
<li><a href="#10"><b class="cmd">call odbc_close( db )</b></a></li>
<li><a href="#11"><b class="cmd">err = odbc_error( db )</b></a></li>
<li><a href="#12"><b class="cmd">call odbc_set_blob_support( db, blob_type )</b></a></li>
<li><a href="#13"><b class="cmd">errmsg = odbc_errmsg( db_or_stmt )</b></a></li>
<li><a href="#14"><b class="cmd">errmsg = odbc_errmsg_print( db_or_stmt, lun )</b></a></li>
<li><a href="#15"><b class="cmd">call odbc_do( db, command )</b></a></li>
<li><a href="#16"><b class="cmd">call odbc_begin( db )</b></a></li>
<li><a href="#17"><b class="cmd">call odbc_commit( db )</b></a></li>
<li><a href="#18"><b class="cmd">call odbc_rollback( db )</b></a></li>
<li><a href="#19"><b class="cmd">call odbc_create_table( db )</b></a></li>
<li><a href="#20"><b class="cmd">call odbc_delete_table( db )</b></a></li>
<li><a href="#21"><b class="cmd">call odbc_prepare_select( db, tablename, columns, stmt, extra_clause )</b></a></li>
<li><a href="#22"><b class="cmd">call odbc_prepare( db, command, stmt, columns )</b></a></li>
<li><a href="#23"><b class="cmd">call odbc_step( stmt, completion )</b></a></li>
<li><a href="#24"><b class="cmd">call odbc_reset( stmt )</b></a></li>
<li><a href="#25"><b class="cmd">call odbc_finalize( stmt )</b></a></li>
<li><a href="#26"><b class="cmd">call odbc_next_row( stmt, columns, finished )</b></a></li>
<li><a href="#27"><b class="cmd">call odbc_insert( db, tablename, columns )</b></a></li>
<li><a href="#28"><b class="cmd">call odbc_get_table( db, commmand, result, errmsg )</b></a></li>
<li><a href="#29"><b class="cmd">call odbc_query_table( db, tablename, columns )</b></a></li>
<li><a href="#30"><b class="cmd">call odbc_get_data_source( next, dsnname, description, success )</b></a></li>
<li><a href="#31"><b class="cmd">call odbc_get_driver( next, driver, description, success )</b></a></li>
<li><a href="#32"><b class="cmd">call odbc_get_table_name( db, next, table, description, success )</b></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>The <i class="term">ODBC</i> module provides a Fortran interface to the
Open Database Connectivity system or ODBC. The interface has been implemented
in such a way, that you can use a high-level interface for common tasks,
such as inserting data into a database and querying the contents, as
well as lower-level functionality, accessible via SQL statements, for
instance.</p>
<p>To this end the module defines a set of routines and functions as well
as several derived types to hide the low-level details.</p>
<p>In its current form, it does not provide a full Fortran API to all the
functionality offered by SQLite, but it should be quite useable.</p>
<p><em>Note:</em> This interface has been modelled after the Fortran SQLite
interface in this same project. Because ODBC is not a database
management system in its own right, but instead an common interface to
various database systems, several additional routines are available,
such as odbc_get_driver, that have no equivalent within the context of
SQLite.</p>
<p><em>Note:</em> While ODBC is intended to provide a generic interface to
database management systems, there are still a number of issues that you
should be aware that depend on the operating system and the specific
database management system.</p>
<p>These issues are documented in <span class="sectref"><a href="#section8">PLATFORM ISSUES</a></span>.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">DATA TYPES</a></h2>
<p>The following derived types are defined:</p>
<dl class="definitions">
<dt><a name="1"><b class="cmd">type(ODBC_DATABASE)</b></a></dt>
<dd><p>Variables of this type are used to hold the connection to the database
or databases. They are created by the subroutine <em>odbc_open</em></p>
<p>The contents are valid until the database is closed (via
<em>odbc_close</em>).</p></dd>
<dt><a name="2"><b class="cmd">type(ODBC_STATEMENT)</b></a></dt>
<dd><p>Variables of this type hold <em>prepared statements</em>, the common
method for database management systems to efficiently execute SQL
statements.</p></dd>
<dt><a name="3"><b class="cmd">type(ODBC_COLUMN)</b></a></dt>
<dd><p>To provide easy communication with the database, ODBC_COLUMN can
hold values of different types. This means you can use a single routine
and variable to transfer strings, integers or reals to and from the
database.</p></dd>
</dl>
<p>The first two derived types are &quot;opaque&quot;, that is they are used only to
communicate between the application and the database library and there
is information of interest to be gotten from them.</p>
<p>The third type is rather crucial to the working of the implementation:
By setting the properties of an ODBC_COLUMN variable you put data into
the database or you can retrieve data from the database. See the example
below for how this works.</p>
<p>There are a number of routines that are meant to make this easier:</p>
<dl class="definitions">
<dt><a name="4"><b class="cmd">call odbc_column_props( column, name, type, length )</b></a></dt>
<dd><p>Set the properties of a column</p>
<dl class="arguments">
<dt>type(ODBC_COLUMN) <i class="arg">column</i></dt>
<dd><p>The variable that holds the information on the column</p></dd>
<dt>character(len=*) <i class="arg">filename</i></dt>
<dd><p>Name of the column in the table to which it belongs or will belong</p></dd>
<dt>integer <i class="arg">type</i></dt>
<dd><p>Type of the column: one of ODBC_INT, ODBC_REAL, ODBC_DOUBLE,
ODBC_CHAR or ODBC_BINARY (see <span class="sectref"><a href="#section8">PLATFORM ISSUES</a></span>).</p></dd>
<dt>integer, optional <i class="arg">length</i></dt>
<dd><p>Length of a character-valued column (defaults to 20 characters)
or a BLOB-type column.</p></dd>
</dl></dd>
<dt><a name="5"><b class="cmd">call odbc_column_query( column, name, type, length, function )</b></a></dt>
<dd><p>Set the properties of a column when constructing a SELECT query.
The &quot;function&quot; argument, if present, is a string representing an SQL function
like <em>count</em> or <em>max</em>.</p>
<dl class="arguments">
<dt>type(ODBC_COLUMN) <i class="arg">column</i></dt>
<dd><p>The variable that holds the information on the column</p></dd>
<dt>character(len=*) <i class="arg">filename</i></dt>
<dd><p>Name of the column in the table to which it belongs or will belong</p></dd>
<dt>integer <i class="arg">type</i></dt>
<dd><p>Type of the column: one of ODBC_INT, ODBC_REAL, ODBC_DOUBLE,
ODBC_CHAR or ODBC_BINARY.</p></dd>
<dt>integer, optional <i class="arg">length</i></dt>
<dd><p>Length of a character-valued column (defaults to 20 characters)</p></dd>
<dt>character(len=*), optional <i class="arg">function</i></dt>
<dd><p>Name of the SQL function to perform on the values.</p></dd>
</dl></dd>
<dt><a name="6"><b class="cmd">call odbc_set_column( column, value )</b></a></dt>
<dd><p>Set the <em>value</em> of a column</p>
<dl class="arguments">
<dt>type(ODBC_COLUMN) <i class="arg">column</i></dt>
<dd><p>The variable that holds the information on the column</p></dd>
<dt>any type <i class="arg">value</i></dt>
<dd><p>The new value for the column. The type of the value that is passed can
be integer, real, double precision real or character string.</p>
<p><em>Note:</em> currently there is no conversion from the type of value that is
stored to the type of the actual variable that is passed to the routine.
If you ask for an integer and the column holds a real, then the result
is undefined. Check the type with the value of the flag &quot;type_set&quot;.
(This is one of the things that should be improved)</p></dd>
</dl></dd>
<dt><a name="7"><b class="cmd">call odbc_get_column( column, value )</b></a></dt>
<dd><p>Get the <em>value</em> of a column</p>
<dl class="arguments">
<dt>type(ODBC_COLUMN) <i class="arg">column</i></dt>
<dd><p>The variable that holds the information on the column</p></dd>
<dt>any type <i class="arg">value</i></dt>
<dd><p>The value stored in the column. The type of the value that is passed can
be integer, real, double precision real or character string.</p></dd>
</dl></dd>
</dl>
</div>
<div id="section3" class="section"><h2><a name="section3">ROUTINES</a></h2>
<p>The <em>odbc</em> module currently provides the following functions:</p>
<dl class="definitions">
<dt><a name="8"><b class="cmd">call odbc_open( filename_or_data_set_name, driver, db )</b></a></dt>
<dd><p>Open a database by <em>data set name</em> or by <em>file name and driver</em>
and store the connection for later use.</p>
<dl class="arguments">
<dt>character(len=*) <i class="arg">filename_or_data_set_name</i></dt>
<dd><p>The name of the data set (DSN, as known to the ODBC system) or the
database file to be opened.</p></dd>
<dt>character(len=*), optional <i class="arg">driver</i></dt>
<dd><p>The name of the driver, currently one of the <em>parameters</em>
ODBC_MSACCESS, ODBC_MSEXCEL, ODBC_SQLITE or ODBC_POSTGRES (see <span class="sectref"><a href="#section8">PLATFORM ISSUES</a></span>).
If left out, the name is supposed to be a data set name (DSN).</p></dd>
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable to identify the database connection</p></dd>
</dl></dd>
<dt><a name="9"><b class="cmd">call odbc_connect( connection_string, db )</b></a></dt>
<dd><p>Open a connection to the database of choice via a full connection
string. This routine is useful if you want specific connection
parameters or if the driver is not directly supported.</p>
<dl class="arguments">
<dt>character(len=*) <i class="arg">connection_string</i></dt>
<dd><p>The connection string to be used. It must contain all information
required (see the documentation on the particular ODBC driver).</p></dd>
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable to identify the database connection</p></dd>
</dl></dd>
<dt><a name="10"><b class="cmd">call odbc_close( db )</b></a></dt>
<dd><p>Close the database connection. Simply an interface to the corresponding
C function.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
</dl></dd>
<dt><a name="11"><b class="cmd">err = odbc_error( db )</b></a></dt>
<dd><p>Retrieve whether the previous command resulted in an error or not.
Returns true if so, otherwise false.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
</dl></dd>
<dt><a name="12"><b class="cmd">call odbc_set_blob_support( db, blob_type )</b></a></dt>
<dd><p>Set the type of support for BLOBs (see <span class="sectref"><a href="#section8">PLATFORM ISSUES</a></span>).
Use this if you intend to use BLOBs (binary large objects).</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db_or_stmt</i></dt>
<dd><p>Variable identifying the database connection.</p></dd>
<dt>integer <i class="arg">blob_type</i></dt>
<dd><p>Identify how the dabase management system supports BLOBs:</p>
<ul class="itemized">
<li><p><em>ODBC_PLAIN_BLOB</em> - (default) the database system uses the keyword &quot;BLOB&quot; to indicate
binary large objects and the ODBC driver simply returns a set of bytes.</p></li>
<li><p><em>ODBC_POSTGRES_HEX</em> - the database system (notably PostgreSQL) uses the keyword &quot;BYTEA&quot; to indicate
binary large objects and the ODBC driver returns a hexdecimally encoded string instead of a set of bytes.</p></li>
</ul></dd>
</dl></dd>
<dt><a name="13"><b class="cmd">errmsg = odbc_errmsg( db_or_stmt )</b></a></dt>
<dd><p>Retrieve the last error message as a string of at most 80 characters.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE/ODBC_STATEMENT) <i class="arg">db_or_stmt</i></dt>
<dd><p>Variable identifying the database connection or the statement that
produced the error.</p></dd>
</dl></dd>
<dt><a name="14"><b class="cmd">errmsg = odbc_errmsg_print( db_or_stmt, lun )</b></a></dt>
<dd><p>Print the last error messages to the screen or to a file</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE/ODBC_STATEMENT) <i class="arg">db_or_stmt</i></dt>
<dd><p>Variable identifying the database connection or the statement that
produced the error.</p></dd>
<dt>integer, optional <i class="arg">lun</i></dt>
<dd><p>LU-number of the file to print the messages to. If not present,
the messages are printed to the screen.</p></dd>
</dl></dd>
<dt><a name="15"><b class="cmd">call odbc_do( db, command )</b></a></dt>
<dd><p>Run a single SQL command</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">command</i></dt>
<dd><p>String holding a complete SQL command</p></dd>
</dl></dd>
<dt><a name="16"><b class="cmd">call odbc_begin( db )</b></a></dt>
<dd><p>Start a transaction. When the corresponding routine odbc_commit is
called, all changes will be made permanent. Use a transaction to gather
lots of changes to the database - this is much faster than an automatic
commission after each change.</p>
<p><em>Note:</em> The database driver may or may not support this feature.
Consult the documentation.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
</dl></dd>
<dt><a name="17"><b class="cmd">call odbc_commit( db )</b></a></dt>
<dd><p>Commit the changes made since the start of a transaction. This makes the
changes permanent.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
</dl></dd>
<dt><a name="18"><b class="cmd">call odbc_rollback( db )</b></a></dt>
<dd><p>Undo the changes made since the start a transaction. The database will
be restored to the state it was in before the transaction was started.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
</dl></dd>
<dt><a name="19"><b class="cmd">call odbc_create_table( db )</b></a></dt>
<dd><p>Create a new table, based on the properties of the columns. Convenience
routine that constructs an SQL statement to do the actual job.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">tablename</i></dt>
<dd><p>Name of the table to be created</p></dd>
<dt>type(ODBC_COLUMN), dimension(:) <i class="arg">columns</i></dt>
<dd><p>An array of the properties of the columns in the tables (name, type,
...)</p></dd>
<dt>character(len=*), optional <i class="arg">primary</i></dt>
<dd><p>Name of the column that acts as the primary key (this gets the
&quot;unique&quot; constraint)</p></dd>
</dl></dd>
<dt><a name="20"><b class="cmd">call odbc_delete_table( db )</b></a></dt>
<dd><p>Delete an existing table by name. Convenience routine that constructs
an SQL statement to do the actual job.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">tablename</i></dt>
<dd><p>Name of the table to be deleted</p></dd>
</dl></dd>
<dt><a name="21"><b class="cmd">call odbc_prepare_select( db, tablename, columns, stmt, extra_clause )</b></a></dt>
<dd><p>Prepare a SELECT query. Convenience routine that creates the SQL query
and &quot;compiles&quot; (prepares) it for later actual execution.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">tablename</i></dt>
<dd><p>Name of the table to be queried</p></dd>
<dt>type(ODBC_COLUMN), dimension(:) <i class="arg">columns</i></dt>
<dd><p>An array of the properties of the columns to be returned</p></dd>
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
<dt>character(len=*), optional <i class="arg">extra_clause</i></dt>
<dd><p>A string holding an extra clause, such as &quot;SORT BY&quot; or &quot;GROUP BY&quot;</p></dd>
</dl></dd>
<dt><a name="22"><b class="cmd">call odbc_prepare( db, command, stmt, columns )</b></a></dt>
<dd><p>Prepare a general SQL statement for later actual execution. The
statement can be any SQL statement.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">command</i></dt>
<dd><p>The SQL statement to be prepared</p></dd>
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
<dt>type(ODBC_COLUMN), dimension(:), pointer <i class="arg">columns</i></dt>
<dd><p>An array of the properties of the columns that will be returned
by the statement. The routine returns an allocated array. You must
deallocate it yourself, when it is no longer needed.</p></dd>
</dl></dd>
<dt><a name="23"><b class="cmd">call odbc_step( stmt, completion )</b></a></dt>
<dd><p>Run the prepared SQL statement for one step. The code in completion
will tell whether it was successful or not. Simply an interface to the
equivalent C routine.</p>
<dl class="arguments">
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
<dt>integer <i class="arg">completion</i></dt>
<dd><p>One of the values ODBC_DONE (success), ODBC_MISUSE or
ODBC_ERROR</p></dd>
</dl></dd>
<dt><a name="24"><b class="cmd">call odbc_reset( stmt )</b></a></dt>
<dd><p>Reset the prepared statement so that it can be used again.</p>
<dl class="arguments">
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
</dl></dd>
<dt><a name="25"><b class="cmd">call odbc_finalize( stmt )</b></a></dt>
<dd><p>Free all resources associated with the prepared statement.</p>
<dl class="arguments">
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
</dl></dd>
<dt><a name="26"><b class="cmd">call odbc_next_row( stmt, columns, finished )</b></a></dt>
<dd><p>Retrieve the next row of a SELECT query. If the argument &quot;finished&quot;
is set to true, the previous row was the last one.</p>
<dl class="arguments">
<dt>type(ODBC_STATEMENT) <i class="arg">stmt</i></dt>
<dd><p>A derived type used as a handle to the prepared statement</p></dd>
<dt>logical <i class="arg">finished</i></dt>
<dd><p>Set to true if the last row was retrieved.</p></dd>
</dl></dd>
<dt><a name="27"><b class="cmd">call odbc_insert( db, tablename, columns )</b></a></dt>
<dd><p>Insert a complete new row into the table.</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">tablename</i></dt>
<dd><p>Name of the table into which the row must be inserted</p></dd>
<dt>type(ODBC_COLUMN), dimension(:) <i class="arg">columns</i></dt>
<dd><p>An array of values for all columns</p></dd>
</dl></dd>
<dt><a name="28"><b class="cmd">call odbc_get_table( db, commmand, result, errmsg )</b></a></dt>
<dd><p>Get the result of a query in a single two-dimensional array</p>
<p><em>NOT IMPLEMENTED YET</em></p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">command</i></dt>
<dd><p>The SQL command (query) to executed</p></dd>
<dt>character(len=*), dimension(:,:), pointer <i class="arg">result</i></dt>
<dd><p>A two-dimensional array that will be filled with the results of the
SQl command. When done, you will have to deallocate it.</p></dd>
<dt>character(len=*) <i class="arg">errmsg</i></dt>
<dd><p>If there is an error, then &quot;result&quot; will not be allocated, and &quot;errmsg&quot;
will contain the information about the error that occurred.</p></dd>
</dl></dd>
<dt><a name="29"><b class="cmd">call odbc_query_table( db, tablename, columns )</b></a></dt>
<dd><p>Query the structure of the table</p>
<dl class="arguments">
<dt>type(ODBC_DATABASE) <i class="arg">db</i></dt>
<dd><p>Variable identifying the database connection</p></dd>
<dt>character(len=*) <i class="arg">tablename</i></dt>
<dd><p>Name of the table to be inspected</p></dd>
<dt>type(ODBC_COLUMN), dimension(:), pointer <i class="arg">columns</i></dt>
<dd><p>An array with the properties of all columns. Deallocate it when you are
done.</p></dd>
</dl></dd>
</dl>
</div>
<div id="section4" class="section"><h2><a name="section4">ODBC-SPECIFIC ROUTINES</a></h2>
<p>The following routines are specific to ODBC:</p>
<dl class="definitions">
<dt><a name="30"><b class="cmd">call odbc_get_data_source( next, dsnname, description, success )</b></a></dt>
<dd><p>Get the first (<i class="term">next = .false.</i>) or the next (<i class="term">next = .true.</i>)
data set name.</p>
<dl class="arguments">
<dt>logical <i class="arg">next</i></dt>
<dd><p>Whether to get the first or the next data set name</p></dd>
<dt>character(len=*) <i class="arg">dsnname</i></dt>
<dd><p>Name of the data set</p></dd>
<dt>character(len=*) <i class="arg">description</i></dt>
<dd><p>Description of the data set (usually includes the driver)</p></dd>
<dt>logical <i class="arg">success</i></dt>
<dd><p>Whether there is a data set name returned or not</p></dd>
</dl></dd>
<dt><a name="31"><b class="cmd">call odbc_get_driver( next, driver, description, success )</b></a></dt>
<dd><p>Get the first (<i class="term">next = .false.</i>) or the next (<i class="term">next = .true.</i>)
registered driver.</p>
<dl class="arguments">
<dt>logical <i class="arg">next</i></dt>
<dd><p>Whether to get the first or the next driver</p></dd>
<dt>character(len=*) <i class="arg">driver</i></dt>
<dd><p>Name of the driver</p></dd>
<dt>character(len=*) <i class="arg">description</i></dt>
<dd><p>Description of the driver</p></dd>
<dt>logical <i class="arg">success</i></dt>
<dd><p>Whether there is a driver name returned or not</p></dd>
</dl></dd>
<dt><a name="32"><b class="cmd">call odbc_get_table_name( db, next, table, description, success )</b></a></dt>
<dd><p>Get information on the first (<i class="term">next = .false.</i>) or the
next (<i class="term">next = .true.</i>) table in a database.</p>
<dl class="arguments">
<dt>logical <i class="arg">next</i></dt>
<dd><p>Whether to get the first or the next table name</p></dd>
<dt>character(len=*) <i class="arg">driver</i></dt>
<dd><p>Name of the table</p></dd>
<dt>character(len=*), dimension(:) <i class="arg">description</i></dt>
<dd><p>Description of the table (at least 5 elements). The fourth element is
the type of table (SYSTEM_TABLE, TABLE or VIEW).</p></dd>
<dt>logical <i class="arg">success</i></dt>
<dd><p>Whether there is a driver name returned or not</p></dd>
</dl></dd>
</dl>
</div>
<div id="section5" class="section"><h2><a name="section5">EXAMPLE</a></h2>
<p>To illustrate the usage of the library, here is a small example:</p>
<ul class="itemized">
<li><p>Store (fictitious) measurements of salinity and temperature from a CSV
file in a single table of a new database.</p></li>
<li><p>To check that it works, retrieve the average salinity and average
temperature per station and print them sorted by station name</p></li>
</ul>
<p>The first part of the program simply defines the table:</p>
<pre class="example">
   allocate( column(4) )
   call odbc_column_props( column(1), name(1), ODBC_CHAR, 10 )
   call odbc_column_props( column(2), name(2), ODBC_CHAR, 10 )
   call odbc_column_props( column(3), name(3), ODBC_REAL )
   call odbc_column_props( column(4), name(4), ODBC_REAL )
   call odbc_create_table( db, 'measurements', column )
</pre>
<p>The second part reads the data file and stores the data in a new row:</p>
<pre class="example">
   call odbc_begin( db )
   do
      read( lun, *, iostat=ierr ) station, date, salin, temp
      if ( ierr .ne. 0 ) exit
      call odbc_set_column( column(1), station )
      call odbc_set_column( column(2), date    )
      call odbc_set_column( column(3), salin   )
      call odbc_set_column( column(4), temp    )
      call odbc_insert( db, 'measurements', column )
   enddo
   close( lun )
   call odbc_commit( db )
</pre>
<p>Note that it uses a transaction (via calls to <em>odbc_begin</em> and
<em>odbc_commit</em> pair), so that all the inserts can be done in
one go. Inserting with autocommit is much slower, as the database file
needs to be flushed very time.</p>
<p>The last part retrieves the data by constructing an SQL query that will
actually look like:</p>
<pre class="example">
    select station, avg(salinity), avg(temperature) from measurements
        grouped by station order by station;
</pre>
<p>The routine <em>odbc_prepare_select</em> takes care of the actual
construction of the above SQL query:</p>
<pre class="example">
   deallocate( column )
   allocate( column(3) )
   call odbc_column_query( column(1), 'station', ODBC_CHAR )
   call odbc_column_query( column(2), name(3), ODBC_REAL, function='avg' )
   call odbc_column_query( column(3), name(4), ODBC_REAL, function='avg' )
   call odbc_prepare_select( db, 'measurements', column, stmt, &amp;
      'group by station order by station' )
   write( *, '(3a20)' ) 'Station', 'Mean salinity', 'Mean temperature'
   do
      call odbc_next_row( stmt, column, finished )
      if ( finished ) exit
      call odbc_get_column( column(1), station )
      call odbc_get_column( column(2), salin   )
      call odbc_get_column( column(3), temp    )
      write( *, '(a20,2f20.3)' ) station, salin, temp
   enddo
</pre>
<p>The full program looks like this (see also the tests/examples
directory of the Flibs project):</p>
<pre class="example">
! csvtable.f90 --
!    Program to read a simple CSV file and put it into a
!    SQLite database, just to demonstrate how the Fortran
!    interface works.
!
!    To keep it simple:
!    - The first line contains the names of the four columns
!    - All lines after that contain the name of the station
!      the date and the two values.
!
!    $Id: fodbc.html,v 1.3 2013/05/13 08:03:15 knystrom Exp $
!
program csvtable
   use odbc
   implicit none
   type(ODBC_DATABASE)                      :: db
   type(ODBC_STATEMENT)                     :: stmt
   type(ODBC_COLUMN), dimension(:), pointer :: column
   integer                                    :: lun = 10
   integer                                    :: i
   integer                                    :: ierr
   character(len=40), dimension(4)            :: name
   real                                       :: salin
   real                                       :: temp
   character(len=40)                          :: station
   character(len=40)                          :: date
   logical                                    :: finished
   !
   ! Read the CSV file and feed the data into the database
   !
   open( lun, file = 'somedata.csv' )
   read( lun, * ) name
   call odbc_open( 'somedata.db', db )
   allocate( column(4) )
   call odbc_column_props( column(1), name(1), ODBC_CHAR, 10 )
   call odbc_column_props( column(2), name(2), ODBC_CHAR, 10 )
   call odbc_column_props( column(3), name(3), ODBC_REAL )
   call odbc_column_props( column(4), name(4), ODBC_REAL )
   call odbc_create_table( db, 'measurements', column )
   !
   ! Insert the values into the table. For better performance,
   ! make sure (via begin/commit) that the changes are committed
   ! only once.
   !
   call odbc_begin( db )
   do
      read( lun, *, iostat=ierr ) station, date, salin, temp
      if ( ierr .ne. 0 ) exit
      call odbc_set_column( column(1), station )
      call odbc_set_column( column(2), date    )
      call odbc_set_column( column(3), salin   )
      call odbc_set_column( column(4), temp    )
      call odbc_insert( db, 'measurements', column )
   enddo
   close( lun )
   call odbc_commit( db )
   !
   ! We want a simple report, the mean of salinity and temperature
   ! sorted by the station
   !
   deallocate( column )
   allocate( column(3) )
   call odbc_column_query( column(1), 'station', ODBC_CHAR )
   call odbc_column_query( column(2), name(3), ODBC_REAL, function='avg' )
   call odbc_column_query( column(3), name(4), ODBC_REAL, function='avg' )
   call odbc_prepare_select( db, 'measurements', column, stmt, &amp;
      'group by station order by station' )
   write( *, '(3a20)' ) 'Station', 'Mean salinity', 'Mean temperature'
   do
      call odbc_next_row( stmt, column, finished )
      if ( finished ) exit
      call odbc_get_column( column(1), station )
      call odbc_get_column( column(2), salin   )
      call odbc_get_column( column(3), temp    )
      write( *, '(a20,2f20.3)' ) station, salin, temp
   enddo
   call odbc_close( db )
end program
</pre>
</div>
<div id="section6" class="section"><h2><a name="section6">LIMITATIONS</a></h2>
<p>The module is not complete yet:</p>
<ul class="itemized">
<li><p>There is no support for blobs or for character strings of arbitrary
length. In fact the maximum string length is limited to 80 characters.</p></li>
<li><p>There is no support for NULL values or for DATE values.</p></li>
<li><p>The ODBC API is not completely covered, though the subset should be
useful for many applications.</p></li>
<li><p>There are no makefiles that can help build the library yet. See the
implementation notes below.</p></li>
</ul>
</div>
<div id="section7" class="section"><h2><a name="section7">IMPLEMENTATION NOTES</a></h2>
<p>While the module is fairly straightforward Fortran 95 code, building a
library out of it may not be straightforward due to the intricacies of
C-Fortran interfacing.</p>
<p>This section aims to give a few guidelines:</p>
<ul class="itemized">
<li><p>The C code contains all the platform-dependent code, so that the Fortran
code could remain clean.</p></li>
<li><p>To support more than one platform, the C code contains several macros:</p>
<ul class="itemized">
<li><p>FTNCALL - the calling convention for Fortran routines (important on
Windows). It is automatically set to <em>__stdcall</em> when the macro
&quot;WIN32&quot; has been defined (by the compiler or by specifying it on the
command-line).</p></li>
<li><p>INBETWEEN - this macro controls whether the hidden arguments for passing
the string length are put inbetween the arguments (if it is defined) or
appended to the end (if it is not defined). Under Windows the Compaq
Visual Fortran compiler used to use the first method, so this is
automatically set. For other platforms the second method is more usual.</p></li>
</ul>
<p>The naming convention (additional underscore, all capitals or all
lowercase) has been handled in a simple-minded fashion. This should be
improved too.</p>
<p>The library has been designed with 64-bits platforms in mind: it should
run on these platforms without any difficulties.</p></li>
</ul>
</div>
<div id="section8" class="section"><h2><a name="section8">PLATFORM ISSUES</a></h2>
<ul class="itemized">
<li><p>The library has been tested on Linux, using the <em>PostgreSQL database</em>
system with the <em>psqlODBC</em> driver.</p>
<p>It is unclear what the proper connection string should be, so that the
type ODBC_POSTGRES for the routine <em>odbc_open</em> does not work yet. (PostgreSQL has
a client/server architecture and can communicate over TCP/IP, so that more information
may have to be specified than for file-based systems like SQLite and MS Access. Use the
routine <em>odbc_connect</em> directly, so that you can pass a complete connection string.)</p></li>
<li><p>As of version 1.1 the library supports so-called binary large objects (column type: ODBC_BINARY).
Not all database systems support them and they are actually an extension to the SQL language
that underlies the communication to and from the database system. For this reason it may be
necessary to use the routine <em>odbc_set_blob_type</em> to identify the database-specific method
used for BLOBs. (It does not seem possible to identify this automatically.)</p></li>
</ul>
</div>
<div id="copyright" class="section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2012 Arjen Markus &lt;arjenmarkus@sourceforge.net&gt;</p>
</div>
</div></body></html>